<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chatbot</title>
    <link rel="stylesheet" href="../static/style.css">
</head>
<body>
	<canvas id="chat-face" width="534" height="400"></canvas>
    <div class="chat-container">
        <h1>Chatbot</h1>
        <div id="chatbox">
            <div id="messages"></div>
        </div>
        <form id="chat-form">
            <input type="text" id="user-input" placeholder="Type your message..." autocomplete="off" required>
			<div id="button-form">
				<button id="speak-button" type="button"></button>
				<button type="submit">Send</button>
			</div>
		</form>
    </div>

    <script>
        const form = document.getElementById('chat-form');
        const messagesDiv = document.getElementById('messages');
		const speakButton = document.getElementById('speak-button');
		//const audioPlayer = document.getElementById('audioPlayer');
		const canvas = document.getElementById('chat-face');
        const ctx = canvas.getContext('2d');
		const bgImage = new Image();
		const listeningImage = new Image();
		const processingImage = new Image();
		const searchingImage = new Image();
		
		let fpsInterval = 100 / 6;
		let then = Date.now();
		let mediaRecorder;
        let audioChunks = [];
		let audioQueue = [];
		let audioCounter = 0;
		let playingAudio = false;
		let micStream; // Store the microphone stream
		
		bgImage.src = "/static/bg.png";
		listeningImage.src = "/static/listening.png";
		processingImage.src = "/static/processing.png";
		searchingImage.src = "/static/searching.png";
		
		let face = {
			timer: 0,
			timer2: 0,
			x: canvas.width / 2,
			y: canvas.height / 2,
			bgx: 0,
			bgy: 0,
			angle: 0,
            color: 'white',
			state: 0,
			habla: false
		};

        let right_eye = {
            x: canvas.width / 2 + 80,
            y: canvas.height / 2 - 67,
			dx: 0,
			dy: 0,
            height: 87,
			angle: 0
        };
		
        let left_eye = {
            x: canvas.width / 2 - 80,
            y: canvas.height / 2 - 67,
			dx: 0,
			dy: 0,
            height: 87,
			angle: -0
        };

        // Rectangle properties
        let mouth = {
            x: canvas.width / 2,
            y: canvas.height / 2 + 80,
			dx: 0,
			dy: 0,
            height: 60,
			angle: 10
        };
		
		async function setupMic() {
			if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
				alert("Your browser does not support audio recording.");
				return;
			}

			try {
				micStream = await navigator.mediaDevices.getUserMedia({ audio: true });
			} catch (error) {
				console.error("Error accessing microphone:", error);
				alert("Error accessing microphone. Please ensure microphone permissions are granted.");
			}
		}
		
		setupMic();
		
		speakButton.onmousedown = function () {
			if (!micStream) {
				alert("Microphone is not available. Please check your permissions.");
				return;
			}

			// Initialize MediaRecorder with the microphone stream
			mediaRecorder = new MediaRecorder(micStream);
			audioChunks = []; // Reset the chunks for a new recording

			mediaRecorder.ondataavailable = (event) => {
				audioChunks.push(event.data); // Collect audio chunks
			};

			mediaRecorder.onstop = async () => {
				face.state = 2;
				
				audioBlob = new Blob(audioChunks, { type: 'audio/wav' }); // Combine chunks into a single Blob
				audioChunks = []; // Clear the chunks for the next recording

				const formData = new FormData();
				formData.append('audio', audioBlob, 'recording.wav'); // Prepare form data

				// Send the recorded audio to the server
				response = await fetch('/query_audio', {
					method: 'POST',
					body: formData,
				});

				if (response.ok) {
					console.log("Audio uploaded successfully.");
					
					data = await response.json();
					
					generateAIResponse(data.response);
				} else {
					face.state = 0;
					console.error("Failed to upload audio.");
				}
			};

			mediaRecorder.start(); // Start recording
			face.state = 1;
			console.log("Recording started...");
		};
		
		speakButton.onmouseup = function () {
			if (mediaRecorder && mediaRecorder.state !== "inactive") {
				mediaRecorder.stop();
				console.log("Recording stopped.");
			}
		};
		
		async function generateAIResponse(user_prompt){
			const userMessageDiv = document.createElement('div');
			userMessageDiv.classList.add('message', 'user');
			userMessageDiv.textContent = user_prompt;
			messagesDiv.appendChild(userMessageDiv);
			
			response = await fetch('/chat_stream', {
				method: 'POST',
				headers: { 'Content-Type': 'application/json' },
				body: JSON.stringify({ message: user_prompt })
			});
			
			const botMessageDiv = document.createElement('div');
			botMessageDiv.classList.add('message', 'bot');
			messagesDiv.appendChild(botMessageDiv);
			
			if (response.ok){
				const phrase_enders = ".?!;]";
				const eventSource = new EventSource('/listen_stream'); // Conéctate al endpoint del servidor
				audioQueue = [];
				audioCounter = 0;
				temp_text = "";
				counter = 0;
				
				eventSource.onmessage = async (event) => {
					face.state = 0;
					text = event.data.substr(0, event.data.length - 1);
					botMessageDiv.textContent += text; // Muestra los datos recibidos
					temp_text += text;
					messagesDiv.scrollTop = messagesDiv.scrollHeight;
					
					index = temp_text.length;
					consult = false;
					
					if (temp_text.includes("[RAG_SEARCH]")){
						face.state = 3;
						botMessageDiv.textContent = "";
						temp_text = "";
						
						return;
					}else if (temp_text.includes("[RAG_FINISHED]")){
						face.state = 2;
						botMessageDiv.textContent = "";
						temp_text = "";
						
						return;
					}
					
					for (let i = 0; i < 5; i++){
						index2 = temp_text.indexOf(phrase_enders[i]);
						if (index2 >= 0){
							consult = true;
							index = Math.min(index, index2);
						}
					}
					
					if (consult){
						text_chunk = temp_text.slice(0, index + 1)
						temp_text = temp_text.slice(index + 1);
						consult = false;
						counter++;
						
						response = await fetch('/generate_audio', {
							method: 'POST',
							headers: { 'Content-Type': 'application/json' },
							body: JSON.stringify({ text: text_chunk, count: counter - 1 })
						});
						
						if (response.ok){
							data = await response.json();
							
							const audioBlob = new Blob([Uint8Array.from(atob(data.audio), c => c.charCodeAt(0))], { type: 'audio/wav' });
							const audioUrl = URL.createObjectURL(audioBlob);
							const audio = new Audio(audioUrl);
							
							audioQueue[data.position] = audio;
						}
					}
				};
				
				eventSource.onerror = (error) => {
					face.state = 0;
					console.error("Error con la conexión SSE.");
					eventSource.close(); // Cierra la conexión si hay un error
				};
			}else{
				botMessageDiv.textContent = `Error: ${data.error}`;
			}

			messagesDiv.scrollTop = messagesDiv.scrollHeight; // Scroll to the bottom
		}
		
		function drawBG(x, y) {
			for (let i = -bgImage.width; i < canvas.width + bgImage.width; i += bgImage.width - 1) {
				for (let j = -2*bgImage.height; j < canvas.height + bgImage.height; j += bgImage.height - 1) {
					ctx.drawImage(bgImage, x + i, y + j);
				}
			}
		}

        // Draw the ellipse
        function drawEllipse(x, y, height, angle, color) {
            ctx.beginPath();
            ctx.ellipse(
                x,
                y,
                60,
                height,
                angle,
                0,
                Math.PI * 2
            );
            ctx.fillStyle = color;
            ctx.fill();
            ctx.closePath();
        }

        // Draw the rectangle
        function drawRectangle(x, y, height, angle, color) {
			ctx.translate(x, y - 15 + height / 2);
            ctx.rotate((angle * Math.PI) / 180);
            ctx.translate(-x, 15 - y - height / 2);
            ctx.beginPath();
            ctx.rect(
                x - 120,
                y - 15,
                240,
                height
            );
            ctx.fillStyle = color;
            ctx.fill();
            ctx.closePath();
			ctx.translate(x, y - 15 + height / 2);
            ctx.rotate(-(angle * Math.PI) / 180);
            ctx.translate(-x, 15 - y - height / 2);
        }
		
		function animate() {
			requestAnimationFrame(animate);

			now = Date.now();
			elapsed = now - then;

			if (elapsed > fpsInterval) {
				then = now - (elapsed % fpsInterval);

				update();
			}
		}

        // Update the animation
        function update() {
			if (audioQueue.length > audioCounter && audioQueue[audioCounter] && !playingAudio){
				audioPlay = audioQueue[audioCounter];
				
				audioCounter++;
				
				audioPlay.onended = () => {
					playingAudio = false;
					face.habla = false;
				};
				
				audioPlay.play().then(() => {
					playingAudio = true;
					face.habla = true;
				}).catch(error => {
					face.habla = false;
				});
			}
			
			face.timer += 1.5;
			
			if (face.habla || face.timer2 > 0){
				face.timer2++;
				if (face.timer2%24 == 0){
					face.timer2 = 0;
				}
			}
			
			face.angle = 5*Math.sin(0.5*face.timer * Math.PI / 180);
			left_eye.dx = 4*Math.sin(1.3*face.timer * Math.PI / 180);
			left_eye.dy = -4*Math.sin(2*face.timer * Math.PI / 180);
			left_eye.angle = 0.122*Math.sin(0.76*face.timer * Math.PI / 180);
			left_eye.height = 46 + 41*Math.cos((360*Math.min(Math.max(face.timer%800, 0), 15) * Math.PI / 180) / 15);
			right_eye.dx = -4*Math.sin(1.1*face.timer * Math.PI / 180);
			right_eye.dy = -4*Math.sin(1.76*face.timer * Math.PI / 180);
			right_eye.angle = -0.122*Math.sin(0.93*face.timer * Math.PI / 180);
			right_eye.height = 46 + 41*Math.cos((360*Math.min(Math.max(face.timer%800, 0), 15) * Math.PI / 180) / 15);
			mouth.dx = 2*Math.sin(0.73*face.timer * Math.PI / 180);
			mouth.dy = 3*Math.sin(0.94*face.timer * Math.PI / 180);
			mouth.angle = -5*Math.sin(1.2*face.timer * Math.PI / 180);
			mouth.height = 60 - 30*Math.cos(15*face.timer2 * Math.PI / 180);
			face.bgx -= 0.5;
			face.bgy += 1.5;
			
			if (face.bgx < -bgImage.width){
				face.bgx += bgImage.width;
			}
			if (face.bgy > bgImage.height){
				face.bgy -= bgImage.height;
			}
			
            // Clear the canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
			
			ctx.translate(face.x, face.y);
			ctx.rotate(0.523);
			ctx.translate(-face.x, -face.y);
				
			if (bgImage.complete){
				drawBG(face.bgx, face.bgy);
			}
			
			if (face.state == 0){
				ctx.translate(face.x, face.y);
				ctx.rotate((face.angle * Math.PI) / 180 - 0.523);
				ctx.translate(-face.x, -face.y);
				
				drawEllipse(left_eye.x + left_eye.dx, left_eye.y + left_eye.dy, left_eye.height, left_eye.angle, face.color);
				drawEllipse(right_eye.x + right_eye.dx, right_eye.y + right_eye.dy, right_eye.height, right_eye.angle, face.color);
				drawRectangle(mouth.x + mouth.dy, mouth.y + mouth.dy, mouth.height, mouth.angle, face.color);
				
				ctx.translate(face.x, face.y);
				ctx.rotate(-(face.angle * Math.PI) / 180);
				ctx.translate(-face.x, -face.y);
			}else{
				ctx.translate(face.x, face.y);
				ctx.rotate(-0.523);
				ctx.translate(-face.x, -face.y);
				
				if (face.state == 1){
					ctx.drawImage(listeningImage, 0, 0);
				}else if (face.state == 2){
					ctx.drawImage(processingImage, 0, 0);
				}else{
					ctx.drawImage(searchingImage, 0, 0);
				}
			}
        }

        // Start the animation
        animate();
        
        form.onsubmit = async (e) => {
            e.preventDefault();
			face.state = 2;
            const userInput = document.getElementById('user-input');
			const prompt = userInput.value;
			
			userInput.value = "";

            generateAIResponse(prompt);
        };
    </script>
</body>
</html>
